---
published: true
---
In this blog post I'll show some analysis I did couple of months ago of a randomly picked Hancitor malware from the malware-traffic-analysis.net web site. The link to the PCAP can be found [here](http://www.malware-traffic-analysis.net/2018/01/29/index2.html).

The purpose of this analysis is to understand the infection mechanics and make sense of the traffic generated by the malware.

Looking at the PCAP file's network connection statistics we can see there are 97 TCP and 9 UDP connections in total.

![connectionstatistics.png]({{site.baseurl}}/_posts/connectionstatistics.png)

The UDP traffic is only domain name resolutions for some interesting web-sites.

![UDPtraffic.png]({{site.baseurl}}/_posts/UDPtraffic.png)

The malware and its components seem to have resolved the following domain name addresses:
christs-ministries.com
api.ipify.org
gosandhegly.com
mail.voicesinprintpublishing.com
neubacher.at
waslohidi.ru
www.google.com

Now let’s focus on the TCP connections by following the first stream in the PCAP file which shows us the traffic when a user clicks on the link in the phishing e-mail.

![]({{site.baseurl}}/https://raw.githubusercontent.com/lockpicksecurity/lockpicksecurity.github.io/master/_posts/3.png)
![3.png]({{site.baseurl}}/_posts/3.png)

The full HTTP hyperlink is trimmed from the PCAP but it’s not that important for our analysis.
We can see that clicking in the link the victim downloads an MS Word document “bofa_payment_167492.doc”

The next stream shows us the malware obtaining the externally visible IP address of the victim through the api.ipify.org web service.

![4.png]({{site.baseurl}}/_posts/4.png)

In the next stream we see the malware making an HTTP POST request against “gosandhegly.com/ls5/forum.php” submitting in clear text system information data from the sandbox machine.

![5.png]({{site.baseurl}}/_posts/5.png)

As a response to that POST request, the server sends back Base64 encoded data to the victim’s machine. As it turns out the “43c” in the returned data is the hexadecimal representation of the length of the Base64 string. The zero character at the end is likely marking the end of the encoded string. We can safely ignore these and just extract the Base64 encoded data for now.

![6.png]({{site.baseurl}}/_posts/6.png)
![7.png]({{site.baseurl}}/_posts/7.png)

Unfortunately running the data through a Base64 decoding routine doesn’t seem to produce any clear text or meaningful data so we’ll leave it for now.

The next network stream is a GET request towards the “mail.voicesinprintpublishing.com” web-site but the returned by the server data is still meaningless as it’s obfuscated in some way.

![8.png]({{site.baseurl}}/_posts/8.png)

The following few streams seem to contain obfuscated data so we can’t tell what is being communicated.

![9.png]({{site.baseurl}}/_posts/9.png)

![10.png]({{site.baseurl}}/_posts/10.png)
![11.png]({{site.baseurl}}/_posts/11.png)


In following communication with the gosandhegly.com C2 server, the returned data again looks Base64 encoded, but is rather small in size.

![12.png]({{site.baseurl}}/_posts/12.png)

It decodes to something meaningless so we assume there is a second layer of obfuscation applied against this data.
![13.png]({{site.baseurl}}/_posts/13.png)

We won’t be able to decrypt the traffic towards waslohidi.ru without the server’s private key as it is TLS encrypted.
![14.png]({{site.baseurl}}/_posts/14.png)

At this point in time, we could not extract much information from the PCAP file so we’ll focus on the document file that gets downloaded when the user clicks on the phishing URL.

We open the document in a safe environment and see it’s asking the user to enable its embedded VB Macro code.

![15.png]({{site.baseurl}}/_posts/15.png)

Upon enabling Macros, Word will automatically execute the Document_Open() function which is the entry point to the malicious code.

![16.png]({{site.baseurl}}/_posts/16.png)

We see that the code will transfer control to the “eyesonly” function, but let’s look around the code first. We see that there are some interesting alias assignments in the “ahtungs”, “barbarian” and “foxitr” modules of the VB code.

![17.png]({{site.baseurl}}/_posts/17.png)

The “tace”, “awakened” and “condole” aliases are assigned to the NtWriteVirtualMemory, NtAllocateVirtualMemory and CreateTimeQueueTimer windows functions accordingly.

The CreateTimeQueueTimer (condole) function is interesting because the third parameter passed to it is a pointer to a callback function which will be executed when the timer expires. Combining this functionality with the other two functions together could be associated with code injection. That is why we set breakpoints in the VB code where they are called and allow the VB Macro code to run.

The first hit is for tace (NtWriteVirtualMemory) but it doesn’t have much to do with the code injection itself.
Next hit is for “awakened” – NtAllocateVirtualMemory which allocates some memory region within the address space of WINWORD.exe with Read/Write/Execute permissions.

![18.png]({{site.baseurl}}/_posts/18.png)

**awakened** -> NtAllocateVirtualMemory(
    IN HANDLE ProcessHandle,         = -1 (self)
    IN OUT PVOID *BaseAddress,      = 0
    IN ULONG ZeroBits,                      = 0
    IN OUT PULONG RegionSize,        = **9352 (0x2488)**
    IN ULONG AllocationType,            = **4096 (0x1000) = MEM_COMMIT**
    IN ULONG Protect );                      = **64 (0x40) = PAGE_EXECUTE_READWRITE**

Next hit is for tace (NtWriteVirtualMemory) which will allocate 5883 bytes of shellcode into this newly allocated region.

![19.png]({{site.baseurl}}/_posts/19.png)

tace ->  NtWriteVirtualMemory(
  IN HANDLE            ProcessHandle,                                         = -1 (self)
  IN PVOID                BaseAddress,                = **100139008 (0x5F80000)**
  IN PVOID                Buffer,                      = 172940788 (0xA4EDDF4)
  IN ULONG              NumberOfBytesToWrite,                           = **5883 (16FB)**
  OUT PULONG        NumberOfBytesWritten OPTIONAL );      = 0

The next hit is at the “condole” (CreateTimeQueueTimer) in the “eyesonly” function, which once completed will transfer control to the shellcode’s entry point at offset 0x1090 from its base (0x5F81090 - 0x5F80000).

![20.png]({{site.baseurl}}/_posts/20.png)

**condole** -> CreateTimerQueueTimer(
  _Out_       PHANDLE             phNewTimer,
  _In_opt_   HANDLE              TimerQueue,
  _In_          WAITORTIMERCALLBACK Callback,    = **100143248 (0x5F81090)**
  _In_opt_   PVOID               Parameter,
  _In_          DWORD               DueTime,
  _In_          DWORD               Period,
  _In_          ULONG               Flags);


We attach a debugger (x64dbg) to the Winword’s process, go to the 0x5F81090 address and set a breakpoint, so that when the CreateTimeQueueTimer function transfers control to the shellcode’s entry point, we can proceed with our analysis from there. We go to the base of the shellcode 0x5F80000 and save 5883 (16FB) bytes from this address to a file called shellcode.bin for further analysis.

Once we’re done with the static code analysis of the shellcode, we can continue with its dynamic analysis in the debugger. The only thing left is to allow the VB debugger of WINWORD to continue execution so we can hit the breakpoint at the shellcode’s entry point.

![21.png]({{site.baseurl}}/_posts/21.png)

Loading the shellcode.bin file in IDA Pro for static analysis doesn’t seem to recognize our entry point at offset 0x1090 as a function, so we’ll have to create one manually and name it “Main”.

![22.png]({{site.baseurl}}/_posts/22.png)

We turn our attention towards the first function call in Main - sub_F01, which seems to accept one interesting and hardcoded parameter. In fact, there are 19 locations within the shellcode where this function is called in with similar values so I’ll rename it to “resoveAPIhash” for now.

![23.png]({{site.baseurl}}/_posts/23.png)

In shellcode and other obfuscated code, in order to hide functionality, malicious code authors hide function names by pre-calculating hash values of their names and compare them with the generated during runtime hash values in order to obtain their addresses and achieve stealth. Since they don’t always go for re-inventing the wheel, they utilize known and available algorithms. The FLARE guys at Mandiant/FireEye used this to their advantage and created the “shellcode_hash_search.py” plugin for IDA Pro to search for such known hashes within the shellcode’s body and mark them accordingly (https://github.com/fireeye/flare-ida/tree/master/python/flare). For the majority of shellcode I have seen in the wild it does a pretty good job. However in this particular example it didn’t find anything. Since the plugin is dependent on an SQLite database file containing pre-calculated hash values, the FLARE guys offer the ability to generate one yourself using the “make_sc_hash_db.py” file. In this case we will try and find the hashing routine, understand the logic behind it, re-implement in FireEye’s script and generate a new database file to use with the plugin.


The hashing routine is located in function sub_E07 (offset 0x0E07) and incorporates some byte shifting and XOR-ing routines that we re-implement in the make_sc_hash_db.py file by adding the following python code:

_def customHancitor(inString,fName):
    val = 0
    for i in inString:
        val = ord(i) ^ ((val >> 0x18) | (val << 0x7))
        val &= 0xFFFFFFFF
    return val
_
We also need to add it in the HASH_TYPES list of tuples and re-create the database file.

Finally the script is able to resolve all the hashes and mark them appropriately in the IDA database file:


![25.png]({{site.baseurl}}/_posts/25.png)

![26.png]({{site.baseurl}}/_posts/26.png)

Now back to looking into the main functionality of the shellcode.
After initially resolving some of the addresses of Windows functions, the shellcode will search for the “**^YOUHO**”magic bytes within loaded by Word’s document file and read 107992 bytes from the end of the magic bytes into a newly allocated buffer.

![27.png]({{site.baseurl}}/_posts/27.png)

This newly allocated buffer goes through a multi-byte XOR routine and is later Base64 decoded.

![28.png]({{site.baseurl}}/_posts/28.png)

In order to extract the executable file we set a breakpoint in the debugger’s where the Base64Decode function is called (offset 0x05F812E8) and we can either get the Base64 string and decode it ourselves or allow the shellcode to do this for us in order to obtain the encoded executable file. We’ll name that executable file “injected.exe”

![29.png]({{site.baseurl}}/_posts/29.png)

Continuing the analysis of the shellcode, we can see that it will spawn an instance of svchost.exe (x86 or x64 depending on MS Word’s version) in a suspended state and perform a process hollowing injection of the newly extracted executable into it.

![30.png]({{site.baseurl}}/_posts/30.png)

Since there’s nothing more to look at the shellcode, we turn our attention at the extracted executable to understand its inner-workings.
After resolving the addresses of Windows API functions, the “injected.exe” malware will generate a unique ID for the system it’s running on, get the username, computer name, external IP address (by sending a request to api.ipify.org) and jump to decoding its RC4 encrypted configuration.

![31.png]({{site.baseurl}}/_posts/31.png)










